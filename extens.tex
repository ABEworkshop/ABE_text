\section{Extension}
some introduction goes here.

%\subsection{Key-abuse  Problem}
%Key-abuse  Problem goes here.

\subsection{Outsource (By Li Peng)}
With the rapid development of cloud computing, a growing number of users choose to share their sensitive data on the clouds. To keep the data security and privacy, encrypting this data is a valid approach before uploading. In addition, this data also should be only accessed to the authenticated users. But it is difficult for traditional public key encryption to realize this demand because it can only realize one-to-one encryption. To handle this problem, ABE is proposed, which provides one-to-many encryption and fine-grained access control of encrypted data.

However, almost all proposed ABE schemes have a main efficiency drawback, that is, computational cost for encryption and decryption is very high. More seriously, the computational cost grows with the complexity of access formula. In a resource-limited device, such as a smart phone, decrypting a ABE ciphertext is very difficult. Suppose that, you are traveling and only taking a smart phone, but your leader suddenly need you to do something immediately and send you a message which is encrypted by ABE. It’s a terrible experience because you can’t decrypt this message using a smart phone.

To leverage computation burden on the user side, Green \emph{et al.} \cite{Matthew:USENIX'11} suggested to outsource decryption in attribute-based encryption. The schemes in \cite{Matthew:USENIX'11} allow a cloud to translate an ABE ciphertext satisfied by that user’s attributes into a (constant-size) ElGamal-style ciphertext. Of course, the coulds who perform the translation operation cannot read any part of messages and the users’ private keys. To outsource the decryption to a could, a user need to split his private key into a “transformation key” (denoted by TK), and an El Gamal-type secret key (denoted by DK). The user give the TK to the cloud, then the could translate the ABE ciphertext into an ElGamal-style ciphertex and send it to the user. Finally, the user utilize the DK to recover the encrypted message. In \cite{Matthew:USENIX'11}, Green \emph{et al.} also proposed replayable CCA(RCCA) security schemes in which the user can check the correctness of recovered message in random oracles(RO). But in their RCCA schemes,a malicious cloud could replace the original ciphertext and its tag which is used to check the correctness. So this method can not strictly guarantee the correctness of transformed ciphertext, to solve this problem, Attribute-Based Encryption with verifiable outsourced decryption was proposed by Lai \emph{et al.} \cite{Junzuo:TIFS'13}. In their schemes, a tag computed by a real message and a random message is used to verify the correctness of the real message. In addition, the original untransformed ciphertext also need to be inputted in the final decryption stage. As a result, this method causes approximately double overhead in both ciphertext size and decryption operation compared with \cite{Matthew:USENIX'11}. To increase the efficiency of ABE with verifiable outsourced decryption in \cite{Junzuo:TIFS'13}, Qin \emph{et al.} \cite{Baodong:TIFS'15} and Lin \emph{et al.} \cite{Suqing:TIFS'15} introduced a key encapsulated mechanism (KEM). Their methods reduce the ciphertext and the computation costs almost by half compared with Lai \emph{et al.}’s scheme \cite{Junzuo:TIFS'13}.
On the other hand, in view of the huge overhead computation in the attribute authority, Li \emph{et al.} \cite{Jin:TPDS'14} proposed a new Secure Outsourced ABE system, which outsource the partial key-issuing and decryption. In their construction, the users’ private keys are associated with users’ attributes and a default attribute. The computation for users’ attributes is outsourced to the clouds and the computation for the default attribute is performed by the attribute authority. The final users’ private key can be gained by combining these two parts. And the method for outsourced decryption is the same as the method in \cite{Matthew:USENIX'11}. Furthermore, this construction also provide the checkability, but it also suffers from the attack existed in Green \emph{et al.}’s schemes \cite{Matthew:USENIX'11}. In \cite{Hui:TDSC'15}, Ma \emph{et al.} proposed two ciphertext-policy attribute-based key encapsulation mechanism (CP-AB-KEM) schemes. Their schemes for the first
time achieve both outsourced encryption and outsourced decryption. Moreover, their schemes not only offer the method to efficiently check the correctness of the outsourced encryption and decryption, but also exculpability, which means a user cannot accuse a Decryption Service Providers(DSP) of returning incorrect results when it return right results.
The efficiency and communication cost comparison is presented in Table~\ref{effcom:outsource} and Table~\ref{comunication:outsource} respectively.
\begin{table*}[htbp]
\centering
 \caption{\label{effcom:outsource}Efficiency Comparison for outsource ABE}
 \begin{tabular}{ccccccc}
  \toprule
  Schemes & Enc(Server)  & Enc(USER) & Dec(Server) &Dec(USER) & Enc.Verify & Dec.Verify\\
  \midrule
 \cite{Matthew:USENIX'11} & $\times$ & $(3\ell +1)E_{G_1}+E_{G_2} $ & $(I+2)P+2|I|E_{G_1} $ & $E_{G_2} $ & $\times $ & $\times $ \\
 \cite{Junzuo:TIFS'13} & $\times$ & $(6\ell+4)E_{G_1}+2E_{G_2} $ & $(4|I|+2)P+2|I|E_{G_2}$  & $2E_{G_1}+2E_{G_2}$ & $\times $ & \checkmark \\
 \cite{Baodong:TIFS'15} & $\times$ & $(3\ell +1)E_{G_1}+E_{G_2} $ & $(|I|+2)P+2|I|E_{G_1} $ & $E_{G_2} $ & $\times $ & \checkmark \\
 \cite{Suqing:TIFS'15} & $\times$ & $(3\ell +3)E_{G_1}+E_{G_2} $ & $(2|I|+1)P+|I|E_{G_2} $ & $2E_{G_1}+E_{G_2} $ & $\times $ & \checkmark \\
  scheme 1 in \cite{Hui:TDSC'15}& $(5\ell+1)E_{G_1} $ & $2E_{G_1}+E_{G_2}$ & $(3|I|+2)P+(4|I|+2)E_{G_1}+|I|E_{G_2} $ & $2E_{G_1}+E_{G_2}$ & \checkmark &  \checkmark \\
 scheme 2 in \cite{Hui:TDSC'15} & $(10\ell+2)E_{G_1} $ & $2E_{G_1}+E_{G_2}$ & $(3|I|+2)P+(|I|+1)E_{G_1}+|I|E_{G_2}$ & $2E_{G_1}+E_{G_2}$ & \checkmark &
 \checkmark \\
  \bottomrule
 \end{tabular}
\end{table*}

\begin{table*}[htbp]
\centering
 \caption{\label{comunication:outsource}Communication Cost Comparison }
 \begin{tabular}{cccc}
  \toprule
  Schemes & Transfer Size(Enc)  & Full Size & Transfer Size(Enc) \\
  \midrule
 \cite{Matthew:USENIX'11} & $\times $ & $(2\ell+1)|G_1|+|G_2|$ & $2|G_2|$ \\
 \cite{Junzuo:TIFS'13} & $\times $ & $(4\ell+3)|G_1|+2|G_2|$ & $|G_1|+2|G_2|$ \\
  \cite{Baodong:TIFS'15} & $\times $ & $(2\ell+1)|G_1|+|G_2|$ & $|G_2|$ \\
 \cite{Suqing:TIFS'15} & $\times $ & $(2\ell+2)|G_1|+|G_2|$ & $|G_2$ \\
 scheme 1 in \cite{Hui:TDSC'15} & $(3\ell+3)|G_1|+3\ell|Z_p| $ & $(3\ell+1)+|G_1|+(3\ell+1)|Z_p| $ & $|G_1|+|G_2|$ \\
 scheme 2 in \cite{Hui:TDSC'15} & $(6\ell+4)|G_1|+4\ell|Z_p| $ & $(3\ell+1)|G_1|+2\ell|Z_p| $ & $|G_1|+|G_2|$ \\
  \bottomrule
 \end{tabular}
\end{table*}





\subsection{Proxy Re-encrypton (by Yi Wang)}
Proxy Re-Encryption (PRE) is a cryptographic primitive first introduced by Blaze \emph{et al.} in 1998. In a PRE scheme, a proxy is allowed to transform a ciphertext encrypted by Alice’s public key into another one that can be decrypted by Bob’s secret key, this process is called re-encryption. Considering this case, an encrypted email is send to Alice, but Alice is off-line. Alice wishes another one Bob could still read the message in her encrypted email. With the PRE system, Bob could decrypted a re-encrypted email of the same message with his own secret key.

In PRE system, the proxy is semi-trusted, but the user(Alice) does’t need to delegate part of his decryption capability to others including the proxy. There is also an advantage that the user could finish any decryption only with his own secret key. So storing any additional decryption key is unnecessary. Otherwise, the proxy authority can only translate one ciphertext into another one under another public key.It is impossible for the delegation to obtain the corresponding plaintext and the original secret keys.With these advantages, PRE can be widely used into many public key cryptosystem.It also have many  practical applications. For example,encrypted email forwarding, distribute file system, and the DRM(Digital Rights Management) of Apple's iTunes.

Since PRE have been introduced in 1998, there are many related works on it. In the paper \cite{Matt:EUROCRYPT'98}, it proposed the first concrete bidirectional PRE scheme. This scheme allows the key holder to publish the proxy function. It applied by untrusted parties without further involvement by the original key holder.Their scheme also has multi-use property. Ateniese \emph{et al.} \cite{Giuseppe:TISSEC'06} presented the first unidirectional.It is a single-use proxy re-encryption scheme. In 2007, Green and Ateniese\cite{Matthew:ACNS'07} provided identity-based PRE.The security of it is in the random oracle model. Chu \emph{et al.} \cite{Chu:ISC'07} proposed new identity-based proxy re-encryption schemes in the standard model. Matsuo \cite{Toshihiko:ICPC'07} also proposed new  identity-based proxy re-encryption system , the solution needs a re-encryption key generator (RKG) to generate re-encryption keys. Guo \emph{et al.} \cite{Shanqing:WUJ'08} proposed the first attribute-based proxy re-encryption(ABPRE) scheme, but their scheme is based on key policy and bidirectional. Liang \emph{et al.} \cite{Xiaohui:ISICCS'09} proposed the first ciphertext policy attribute-based proxy re-encryption(CP-ABPRE) scheme which has the above properties except re-encryption control.In TCC 2012, Chandran \emph{et al.} \cite{Shanqing:TTC'12} proposed an obfuscation for functional re-encryption with collusion resistant property. Recently, a CCA secure CP-ABPRE was proposed in \cite{Kaitai:INCS'13}, in this paper the scheme is proven in the random oracle model. In\cite{Kaitai:ISPEC'14}, a CP-ABPRE system was built and proven secure against CCA in the standard model.\\

Next, we will give an ABPRE model in\cite{Xiaohui:ISICCS'09}.\\

Definition:  \emph{An} ABPRE  \emph{scheme is a tuple of probabilistic polynomial time algorithms} (Setup, KeyGen, RKGen, Enc, ReEnc, Dec).

\begin{itemize}
\item \textbf{Setup}($1^k$)$\rightarrow$(\emph{pp,mk}): On input a security parameter $1^k$, the setup algorithm SETUP outputs a system public parameter \emph{pp} and a master key \emph{mk}.
\item \textbf{KeyGen}(\emph{S;mk})$\rightarrow$(\emph{usk}): On input an index set \emph{$S^1$} and a master key \emph{mk}, the key generation algorithm KEYGEN outputs a secret key \emph{usk}.
\item \textbf{RKGen}(\emph{usk};\emph{AS})$\rightarrow$(\emph{rk}): On input a secret key \emph{usk} and an access structure \emph{AS}, the re-key generation algorithm RKGEN outputs a re-key \emph{rk}.
\item \textbf{Enc}(\emph{AS};\emph{m})$\rightarrow$(\emph{C}): On input an access structure \emph{AS} and a message \emph{m}, the encryption algorithm ENC outputs a ciphertext \emph{C}.
\item \textbf{ReEnc}(\emph{rk};\emph{C})$\rightarrow$(\emph{$C'$}): On input a re-key \emph{rk} and a ciphertext \emph{C}, the re-encryption algorithm REENC first checks if the index set in \emph{rk} satisfies the access structure of \emph{C}. Then, if check passes, it outputs a re-encrypted ciphertext \emph{$C'$}; otherwise, it outputs ``reject''.
\item \textbf{Dec}(\emph{usk};\emph{C})$\rightarrow$(\emph{m}): On input a secret key \emph{usk} and a ciphertext \emph{C}, the decryption algorithm DEC first checks if the index set in \emph{usk} satisfies the access structure of \emph{C}. Then, if check passes, it outputs a message \emph{m} in the message space; otherwise, it outputs ``reject''.
\end{itemize}

Then, we present the construction with six algorithms Setup, KeyGen, ENC, RKGen, ReEnc, Dec.\\

\noindent
\textbf{Setup}($1^k$) Generate a bilinear group \emph{G} of prime order \emph{p}, with bilinear map \emph{e}:\emph{G}$\times$\emph{G} $\rightarrow$ \emph{$G_{T}$}. Next, it selects elements \emph{y}, \emph{$t_{i}$}(1$\leq$\emph{i}$\leq$3\emph{n}) in \emph{$Z_{p}$} and two generators \emph{g, h} of \emph{G} at random. Let \emph{Y}:=\emph{$e(g, h)^y$} and \emph{$T_{i}$}:=\emph{$g^{t_{i}}$}, \emph{$T'_{i}$}:=\emph{$h^\frac{1}{t_{i}}$}, for each 1$\leq$\emph{i}$\leq$3\emph{n}. The public parameter \emph{pp} includes
$\langle$
\emph{e, g, h, Y, ${\{T_{i}, T'_{i}\}}_{1\leq i\leq 3n}$}
$\rangle$.
The master key \emph{mk} is $\langle$\emph{$y, \{{t_{i}}\}_{1\leq i\leq 3n}$}$\rangle$.\\

\noindent
\textbf{KeyGen}(\emph{S}, \emph{mk}) Let \emph{S} denote an index set of attributes. It chooses random \emph{$r_{1}$}$\cdots$\emph{$r_{n}$} from \emph{$Z_{p}$} and sets \emph{$r = r_{1} + r_{2} +\cdots+ r_{n}$}. Compute \emph{$\hat{D}$}=\emph{$h^{y-r}$},  and for each \emph{i} $\in$ $\mathcal{N}$($\mathcal{N}$=\{1, 2, $\cdots$, \emph{n}\}): if \emph{i} $\in$ \emph{S}, \emph{$D_{i, 1}$}=\emph{$h^\frac{r_{i}}{t_{i}}$}, \emph{$D_{i, 2}$}=\emph{$h^\frac{r_{i}}{t_{2n+i}}$}; otherwise, \emph{$D_{i, 1}$}=\emph{$h^\frac{r_{i}}{t_{n+i}}$}, \emph{$D_{i, 2}$}=\emph{$h^\frac{r_{i}}{t_{2n+i}}$}. It outputs a user's secret key \emph{usk}=$\langle$\emph{$S, {(D_{i, 1}, D_{i, 2})}_{i \in \mathcal{N}}, \hat{D}$}$\rangle$.\\

\noindent
\textbf{Enc}(\emph{m}, \emph{AS}) Let \emph{AS} denote an access structure. To encrypt a message \emph{m} $\in$ \emph{$G_{T}$}, it selects random \emph{s} $\in$ \emph{$Z_{p}$} and computes $\tilde{C}$=\emph{$m\cdot Y^s$}, $\hat{C}$=\emph{$g^s$}, $\breve{C}$=\emph{$h^s$}. For \emph{i} $\in$ $\mathcal{N}$: if \emph{$+d_{i}$} appears \emph{AS}, \emph{$C_{i}=T^s_{i}$}; if \emph{$-d_{i}$} appears \emph{AS}, \emph{$C_{i}=T^s_{n+i}$}; otherwise \emph{$C_{i}=T^s_{2n+i}$}. It outputs \emph{C}=$\langle$\emph{$AS, \tilde{C}, \hat{C}, \breve{C}, (C_{i})_{(i \in \mathcal{N})}$}$\rangle$.\\

\noindent
\textbf{RKGen}(\emph{usk}, \emph{AS}) Let \emph{usk} denote a valid secret key consisting of $\langle$\emph{$S, {(D_{i, 1}, D_{i, 2})}_{i \in \mathcal{N}}, \hat{D}$}$\rangle$. and \emph{AS} denote an access structure.It selects random \emph{d} $\in$ \emph{$Z_{p}$} and set \emph{$\mathfrak{D}=g^d, \hat{D}'=\hat{D}$}. For \emph{i} $\in$ $\mathcal{N}$: if \emph{i} $\in$ \emph{S}, \emph{$D_{i, 1}'$}=\emph{$D_{i, 1}\cdot(T_{i}')^d$}, \emph{$D_{i, 2}'$}=\emph{$D_{i, 2}\cdot(T_{2n+i}')^d$}; otherwise, \emph{$D_{i, 1}'$}=\emph{$D_{i, 1}\cdot(T_{n+i}')^d$}, \emph{$D_{i, 2}'$}=\emph{$D_{i, 2}\cdot(T_{2n+i}')^d$}; $\mathfrak{C}$ is the ciphertext of $\mathfrak{D}$ under the access structure \emph{AS}.

It outputs \emph{rk}=$\langle$\emph{$S, AS, {(D'_{i, 1}, D'_{i, 2})}_{i \in \mathcal{N}}, \hat{D}', \mathfrak{C}$}$\rangle$.\\

\noindent
\textbf{ReEnc}(\emph{rk}, \emph{C}) Let \emph{rk} denote a valid re-key consisting of $\langle$\emph{$S, AS', {(D'_{i, 1}, D'_{i, 2})}_{i \in \mathcal{N}}, \hat{D}', \mathfrak{C}$}$\rangle$ and \emph{C} denote a well-formed ciphertext $\langle$\emph{$AS, \tilde{C}, \hat{C}, \breve{C}, (C_{i})_{(i \in \mathcal{N})}$}$\rangle$, It checks if \emph{S} satisfies \emph{AS}, if not, output $\bot$; otherwise, for \emph{i} $\in$ $\mathcal{N}$:
\begin{itemize}
\item \emph{$+d_{i}$} appears in \emph{AS}, \emph{$E_{i}=e(C_{i}, D'_{i, 1})=e(g^{t_{i}s}, h^\frac{r_{i}+d}{t_{i}})=e(g, h)^{s(r_{i}+d)}$};
\item \emph{$-d_{i}$} appears in \emph{AS}, \emph{$E_{i}=e(C_{i}, D'_{i, 1})=e(g^{t_{n+i}s}, h^\frac{r_{i}+d}{t_{n+i}})=e(g, h)^{s(r_{i}+d)}$};
\item otherwise, \emph{$E_{i}=e(C_{i}, D'_{i, 1})=e(g^{t_{2n+i}s}, h^\frac{r_{i}+d}{t_{2n+i}})=e(g, h)^{s(r_{i}+d)}$};
\end{itemize}

It then computes $\bar{C}$=\emph{$e(\hat{C}, \hat{D}')\prod_{i \in \mathcal{N}}E_{i}=e(g^s, h^{y-\sum^n_{i=1}r_{i}})\cdot e(g, h)^{nds+s\sum^n_{i=1}r_{i}}=e(g, h)^{nds+ys}$}; output a re-encrypted
ciphertext \emph{$C'$}=$\langle$\emph{$AS', \tilde{C}, \bar{C}, \breve{C}, \mathfrak{C}$}$\rangle$.

\textbf{Dec}(\emph{C}, \emph{usk}) Let \emph{usk} denote a valid secret key $\langle$\emph{$S, {(D_{i, 1}, D_{i, 2})}_{i \in \mathcal{N}}, \hat{D}$}$\rangle$. It checks if \emph{S} satisfies \emph{AS}, if not, output $\bot$; otherwise, do
\begin{enumerate}
\item If C is an original well-formed ciphertext consisting of $\langle$\emph{$AS, \tilde{C}, \hat{C}, \breve{C}, (C_{i})_{(i \in \mathcal{N})}$}$\rangle$, for \emph{i} $\in$ $\mathcal{N}$:
    \begin{itemize}
\item \emph{$+d_{i}$} appears in \emph{AS}, \emph{$E_{i}=e(C_{i}, D_{i, 1})=e(T^s_{i}, h^\frac{r_{i}}{t_{i}})=e(g, h)^{sr_{i}}$};
\item \emph{$-d_{i}$} appears in \emph{AS}, \emph{$E_{i}=e(C_{i}, D_{i, 1})=e(T^s_{n+i}, h^\frac{r_{i}}{t_{n+i}})=e(g, h)^{sr_{i}}$};
\item otherwise, \emph{$E_{i}=e(C_{i}, D_{2n+i, 1})=e(T^s_{i}, h^\frac{r_{i}}{t_{2n+i}})=e(g, h)^{sr_{i}}$};
    \end{itemize}
It outputs \emph{$\frac{\tilde{C}}{e(\hat{C}, \hat{D})\cdot\prod_{i \in \mathcal{N}}E_{i}}=\frac{m\cdot e(g, h)^{ys}}{e(g, h^{y-r})\cdot e(g, h)^{sr}}=m$}.
\item Else if \emph{C} is a re-encrypted well-formed ciphertext consisting of $\langle$\emph{$AS', \tilde{C}, \bar{C}, \breve{C}, \mathfrak{C}$}$\rangle$, it decrypts $\mathfrak{C}$ using \emph{usk} and obtains $\mathfrak{D}=g^d$. Then, it outputs \emph{$\frac{\tilde{C}e(\mathfrak{D}, \breve{C})^n}{\bar{C}}=\frac{m\cdot e(g, h)^{ys}\cdot e(g^d, h^s)^n}{e(g, h)^{ys+nds}}=m$}.
\item Else if \emph{C} is a multi-time re-encrypted well-formed ciphertext, decryption is similar with the above phases.
\end{enumerate}

\subsection{Multi-authority And distributed ABE}

\subsubsection{Multi-authority And distributed ABE( by Prince)}
In Distributed systems, it will not be user-friendly for access rules for objects to be based on identities considering the various dynamic sets of users in todays computing environment. In light of the above, the incipient proposal of Attribute Based Encryption in a landmark work by A. Sahai and B. Waters in 2005\cite{Sahai:EUROCRYPT'05} and later by Goyal \emph{et al.} \cite{Goyal:CCS'06} opened up various interests to the research community.

In the traditional ABE scheme, there exist a central authority (CA) in charge of all attributes and responsible for the issuance of secret keys to users for decryption. Consequently, the CA can decrypt every ciphertext in the system by calculating the required secret keys at any time, this is the {\it key escrow problem} of ABE\cite{Rao:CMS'13}. This problem triggered the conceptualization of multi-authority and distributed ABE schemes. Imperatively, there are two major concepts under the ABE scheme, namely:

Key-Policy ABE (KP-ABE). In these schemes, the secret keys are associated with an access structure, while the ciphertext is labeled with a set of attributes\cite{Sahai:EUROCRYPT'05}, \cite{Goyal:CCS'06}, \cite{Chase:TCC'07}, \cite{Ostrovsky:CCS'07}.

Ciphertext-Policy ABE (CP-ABE). In these schemes, the ciphertext is associated with an access structure, while the secret keys are labeled with a set of attributescite\cite{Bethencourt:SP'07},\cite{Cheung:CCS'07}, \cite{Cheung:EUROCRYPT'10}.

Even though some prior researchers\cite{Yuan:ICWS'05}\cite{Adelsbach:ICISC'06}\cite{Kapadia:NDSS'07}\cite{Bradshaw:CCS'04} proposed some form of multi-authority, it was noted by Mller \emph{et al.} \cite{Sascha:ICISC'08} that the techniques used in these applications are not collusion-resistant, so they can not be classified as ABE.


\textbf{The first Multi-Authority}


In 2007 Chase\cite{Chase:TCC'07} introduced what could be considered as the first  Key-Policy ABE with multi-authority since she introduced various authorities with global identifiers to keep a users' keys in sync in her scheme. However, these authorities were fixed during initialization and threshold gates were used as access policy. One dominant downside of his scheme was that, it depended on a {\it Central Authority} (CA).


\textbf{Distributed Attribute-Based Encryption}


One year later (2008), Mller \emph{et al.} \cite{Sascha:ICISC'08}, introduced the concept of Distributed Attribute-Based Encryption (DABE) using Cipertext-Policy, that supports an arbitrary number of attribute authorities where both the authorities and users could join the system any time. Nonetheless, one central authority{\em (Master)} is dedicated to the distribution of user secret keys and an arbitrary number of Attribute authorities responsible for the verification of user eligibility and the distribution of secret attribute keys to the users.

Their scheme constructs access policies using the Disjointed Normal Form (DNF). Compared to earlier ABE schemes, the DABE is fairly efficient as most of its computation uses group operations in bilinear group except during the decryption stage where it uses two time of the bilinear pairing for the computation.
Mller \emph{et al.} secured their scheme in the random oracle model and provided a security proof using the adaptive model.

\subsubsection{ Decentralized Attribute Based Encryption( by Prince)}
One natural feature of decentralized ABE systems is the absence of a central authority (CA). Lin \emph{et al.} \cite{Huang:INDOCRYPT'08} proposed the first non-CA multi-authority ABE taking advantage of Distributed Key Generation (DKG) protocol and Joint Zero Secret Sharing (JZSS) protocol to replace the CA. However, this scheme can only resist collusion up to collusion of {\em m} users. Where {\em m} was a fixed system parameter chosen at setup. In 2009, Chase \emph{et al.} \cite{Chase:CCS'09} constructed a CA-free multi-authority ABE which solved the key escrow problem in\cite{Chase:TCC'07} using distributed Pseudo Random Functions (PRF) and key-policy with AND-gate access structure. The scheme is limited to handling only a set of fixed number of authorities at system initialization.

Lewko \emph{et al.} \cite{Lewko:EUROCRYPT'11} introduced a novel decentralized multi-authority scheme which is CA-free. The scheme which is a ciphertext-policy ABE, functions entirely independently where any party can become an authority and authorities need not even be aware of each other. He based his scheme on the concept of global identifier introduced by Chase\cite{Chase:TCC'07} to bind attribute-related secret keys of a user from different authorities together, thereby preventing collusion attack. The scheme is secured in the random oracle model and proven secured using the adaptive model.
Liu \emph{et al.} \cite{Zhen:ESORICS'11} came up with a LSSS multi-authority CP-ABE system which has multiple CAs and authorities. The scheme is adaptively secure without random oracles unlike Lewko and Waters.


\textbf{Decentralized Ciphertext-Policy Attribute-Based Encryption Scheme with Fast Decryption}


In most of the multi-athorities mentioned above, the ciphertext size are huge likewise the linear-size of the bilinear pairing. To help solve this problem,\cite{Sascha:ICISC'08} propose an efficient multi-authority decentralized Ciphertext-Policy Attribute-Based Encryption scheme for Monotone Access Structures (MAS) with fast decryption, where no Central Authority exists and all authorities function independently without being aware of each other.

The security of this scheme is built on the generic bilinear group model\cite{Victor:EUROCRYPT'97} \cite{Boneh:EUROCRYPT'05} and proven secured adaptively. It is collusion resistance and also secured against the escrow problem.
In comparison with\cite{Lewko:EUROCRYPT'11}, this scheme's decryption time is constant for general MAS giving it fast performance. Furthermore, it provides a mechanism for packing multiple messages in a single ciphertext which makes it more efficient to use.

\textbf{Large universe decentralized key-policy attribute-based encryption}


Li \emph{et al.} \cite{Qi:SCN'14} present a large universe decentralized key-policy ABE scheme on prime order groups without any central authority where attribute authority executes independently from the others and can join or depart the system anytime.

This system supports a large universe of attributes and does not impose any bounds on the set of attributes, which will be used in encryption. It is constructed in the standard security model and proven secured with the selective model.


\subsubsection{Privacy-Preserving in Attribute-Based Encryption( by Prince)}
Over the past years Multi-Authority  ABE has been expanded and improved upon by various researchers in this field. Attribute-Based Encryption, where a user in the system can share his encrypted data based on access policy defined by him and only users whose attributes satisfy the policy can subsequently decrypt and have access to the shared data. This can be considered as an efficient and convenient primitive to use in pervasive computing environments.

Even though this primitive brings flexibility, it also materialized security concerns. Notably among them is the problem where authorities can collect the attributes of users and consequently decrypt messages or in worse case, impersonate the user.

Considering the security of attributes of users, Han \emph{et al.} \cite{Jinguang:TPDS'12} introduced the first privacy-preserving decentralized key-policy ABE scheme where each authority can issue secret keys to a user independently without knowing anything about his GID. Thereby protecting the user's privacy. Their scheme is designed in the standard security model and proven secure in the selective model.
Using privacy-preserving key extraction protocol method and a global identifier (GID), they tied the user's access to all authorities to prevent collusion attacks.

Unfortunately, by breaking the weak ties between authorities, (to remove such a connection by changing the identifier associated with particular secret keys) Ge \emph{et al.} \cite{Aijun:TPDS'13}, proved that the scheme "{\em Privacy-Preserving Decentralized Key-Policy Attribute-Based Encryption}" proposed by Han \emph{et al.} in 2012 is open collusion attacks in the standard model.

In 2014, Han \emph{et al.} \cite{Aijun:TPDS'13} proposed a privacy-preserving decentralized CP-ABE (PPDCP-ABE) scheme where the central authority is not required and each authority can work independently without the cooperation to initialize the system and the user can convince the authorities that the attributes for which he is obtaining secret keys are monitored by them without compromising the GID and the attributes of the user. This scheme is built on standard model and proven secured in the selective model. Furthermore the scheme is based on the Privacy-Preserving Key Extract Protocol and Linear Secret Sharing Schemes.

On the other hand, Wang \emph{et al.} \cite{Jinguang:ESORICS'14} gave a security analysis of PPDCP-ABE scheme of Han \emph{et al.} \cite{Aijun:TPDS'13} and point out the security weakness of their scheme. It came out that their basic decentralized ciphertext-policy ABE scheme cannot resist collusion attacks. Also, the privacy-preserving key extract protocol proposed by\cite{Aijun:TPDS'13}, allows the authority to reveal users' credentials, hence, the privacy protection of attributes cannot be provided.


 \textbf{User Collusion Avoidance Scheme for Privacy-Preserving Decentralized Key-Policy Attribute-Based Encryption}


More recently in september 2016, Rahulamathavan \emph{et al.} \cite{Minqian:CCPE'15} have proposed a user collusion avoidance scheme which preserves the user's privacy when they interact with multiple authorities to obtain decryption credentials. This they achieved by tying secret known for Attribute Authority and secret known for the user in a non-linear fashion.
Further, by modify the scheme in \cite{Aijun:TPDS'13} using the anonymous key issuing protocol in \cite{Chase:CCS'09} to secure the bind between decryption keys and GID as well as to preserve the user's privacy while the Attribute Authority is guaranteed that the decryption-keys are the only information that the user learns from the transaction using blind IBE schemes \cite{Camenisch:PKC'09}.

This scheme has been designed on the standard security model (decisional bilienar Deffie-Hellman assumption. It is proven to be secured in the selective ID model agains collusion attacks and chosen plain attacks.
However, in terms of performance, the proposed scheme works a bit slower compared to other schemes like Han \emph{et al.}

\subsubsection{Revocable Decentralized Attribute-Based Encryption( by Prince)}
The introduction of decentralized multi-authority thwarted most drawbacks of the single authority and brought about flexibility where different users with arbitrary attributes are given various forms of access to different types of encrypted data. In the real world, attributes of users could change periodically. This prompted researchers to investigate revocation in ABE where occasional key updates would allow only the eligible non-revoked users to be able to decrypt recently encrypted data.

Revocation in ABE can be described in two major ways:

1. {\em indirect revocation} \cite{Nuttapong:ICCC'09}. This form of revocation invokes key updates from the authority periodically, such that only non-revoked users' keys can receive the available updates, thereby rendering revoked users' keys useless.

2. {\em direct revocation} \cite{Nuttapong:ICCC'09}. This form of revocation invokes key updates from the sender directly. This he does by stipulating the revocation list when encrypting the ciphertext.

Attrapadung \emph{et al.} \cite{Nuttapong:ICCC'09} proposed a user-revocable ABE scheme by combining broadcast encryption schemes with ABE schemes where the data owner must take complete responsibility of maintaining the membership lists for each attribute group to ensure the direct user revocation. This scheme will not work on data outsourcing platform, since the data owner will no longer have direct control of data distribution after outsourcing the data to the external service providers.

Liang \emph{et al.} \cite{Xiaohui:Citeseer'10} offered a CP-ABE scheme with efficient revocation. Their construction is built on the linear secret sharing and binary tree techniques, and proven secure in the standard model. Besides the attribute set, users are also tagged with a unique identifier which can be used to revoke easily.

All the above schemes\cite{Nuttapong:ICCC'09}\cite{Xiaohui:Citeseer'10} support user revocation, but they have no effect on attribute revocation.


 \textbf{Revocable and Decentralized Attribute-Based Encryption}


Recently Cui \emph{et al.} \cite{Hui:CJ'16}presented a decentralized ciphertext-policy ABE (CP-ABE) system supporting indirect revocation which splits the exclusive AA's role across multiple AAs such that the AAs can indirectly accomplish revocation by stopping updating the keys for the revoked users.
The splitting of roles across multiple AAs, reduces the computational overhead at the same time keeping the system decentralized where by any party can become an authority by creating a public and private key pair.

To prevent revoked users from combining their keys with non-revoked users (collusion), Cui \emph{et al.} bonded the time period and the global identifier during the key generation process at the same time keeping the global identifier away during the encryption stage.

Comparatively, Cui \emph{et al.}'s scheme could be considered scalable as against \cite{Nuttapong:ICCC'09} and \cite{Alexandra:CCS'08}. this is because an attribute can freely be added or revoked at any time without modifying the operation of the system.

This scheme is securely constructed in the standard model. The dual encryption security technique is applied during the security proof. The keys and the ciphertexts are divided as normal and semi-functional: the normal keys can decrypt the semi-functional ciphertexts, the semi-functional keys can decrypt the normal ciphertexts, but the semi-functional keys cannot decrypt the semi-functional ciphertexts \cite{Brent:CRYPTO'09}.


\subsubsection {Summary( by Prince)}




\begin{table}[htp]
\caption{default}
\begin{center}
\begin{tabular}{ccc}
\hline
ColA & ColB & ColC\\
\hline
43 & 200 & 75\\
280 & 16 & 88\\
102 & 77 & 340\\
\hline
\end{tabular}
\end{center}
\label{default}
\end{table}%


\subsubsection{Multi-authority And distributed ABE (by Ziheng Ding)}
\indent In traditional Attribute Based Encryption(ABE) scheme, it cannot solve the problem when attributes belong to diverse servers, since these servers cannot be totally trusted by others. For instance, if attributes which are ID number and major of one user belong to governmental authority and college respectively, information is unable to be shared because government and college do not believe each other. To solve this problem, the first solution titled Multi-Authority Attribute Based Encryption\cite{Chase:TCC'07} was proposed. Two methods was introduced in this scheme. The first one is Global Identifier(GID), which means every receiver is given a unique number illustrating their identity. GID are able to be verified by all authorities, while no one would have access to it expect the user himself. Another tool is Central Authority which is totally trusted by all users and other authority. The specific scheme was divided into 5 steps:

\noindent\textbf{System}  It output the system public key and security parameter and system public key Y$_{0}$.   \\
\textbf{Attribute Authority k} For authority k, authority secret key (s$_{k}$,t$_{k,1}$...t$_{k,n}$,) and authority public key (T$_{k,1}$...T$_{k,n}$) is established in this step.Besides, user u would have a unique secret key D$_{k,i}$ here.\\
\textbf{Central Authority}  Every authority gets a central authority secret key s$_{k}$ here. Like other authority, a secret key D$_{CA}$ would be established. Noteworthy is that includes the secret key of all authorities.   \\
\textbf{Encrypt}  this algorithm that takes a message m as input and the cipher text as output (E,E$_(CA)$).\\
\textbf{Decrypt} Receiver has to recover the message according to its attributes.\\
\indent The advantages are obvious. Central authority ensure that the scheme is safe even if some normal authorities are corrupted. To be more specific,when some are dishonest,the secret key of Central authority could prevent illegal decryption by other attributes which are still honest. It is also arguable that authorities are able to decrease their burden distributing secret keys as well as monitoring attributes. Since each attribute is monitored by a diverse authority and central authority monitor none. In addition,an increasing number of schemes was proposed to perfect Multi-Authority ABE with more functions. For example,in MA Verifiable ABE\cite{Qiang:JWU'08}, user has ability to check which authority gives wrong secret key and when key of authority fails in verification, he only need to send corresponding part again. In MA-ABE Scheme with Revocation \cite{XiaoFang:ICCCN'15}, revocation could be achieved by using attributes classification management.Cloud computing is also utilized in MA-ABE which is introduced in Online/offline unbounded MA-ABE for data sharing in mobile cloud computing \cite{Yinghui:Wiley'16}.
\indent On the other hand, central authority are prone to bring certain risks that if it was corrupted, the whole scheme would be broken. Due to reducing the severe reliance on central authority, the Secure threshold multi authority attribute based encryption without a central authority was introduced\cite{Huang:INDOCRYPT'08}. Two protocols, distributed key generation protocol (DKG) and joint zero secret sharing protocol (JZSS), make the major contribution.Another approach is that several authorities could be in charge of the authorized specific attributes' key distribution in Efficient Statically-Secure Large-Universe Multi-Authority Attribute-Based Encryption\cite{Yannis:FC'15}.
\\
\indent In terms of security,a wide range of security models is used in these proposals,which lies in the table1.
\\
%\begin{table}
%\caption{assumption}
% \centering
%\scalebox{1.0}{
%\begin{tabular}{|c|c|}
%\hline
%scheme&security\\
%\hline
%\cite{Chase:TCC'07}& Bilinear BDH assumption\\
%\hline
%\cite{Huang:INDOCRYPT'08}&         Decisional BDH assumption\\
%\hline
%\cite{Qiang:JWU'08}&        Decisional BDH assumption\\
%\hline
%\cite{Zhen:ESORICS'11}&          Number-Theoretic assumptions\\
%\hline
%\cite{Yannis:FC'15}&       Complexity assumption\\
%\hline
%\cite{XiaoFang:ICCCN'15}&      Decisional BDH assumption\\
%\hline
%\cite{Qi:Wiley'15}&       z-type assumption\\
%\hline
%\cite{Yinghui:Wiley'16}&q-type problem\\
%\hline
%\end{tabular}}
%\end{table}
\\
\indent table2 and table 3 contains the comparison in the length of user's key and ciphertext and performance comparison. t$_{e1}$,t$_{e2}$ denotes the time spent on two different bilinear group operations, t$_{p}$ denotes the time spent on pairing operation, k means the number of authority. The table compares the efficiency of diverse scheme.
\\
\begin{table*}
\caption{the comparison in the length of user's key and ciphertext  }
 \centering
\begin{tabular}{|c|c|c|c|c|c|}
\hline
scheme&private key&ciphertext&encryption&decryption&security\\
\hline
\cite{Chase:TCC'07}&nG$_{1}$&nG$_{1}$+G$_{2}$&t$_{p}$+nt$_{e1}$+t$_{e2}$&t$_{p}$+kt$_{e2}$& Bilinear BDH assumption\\
\hline
\cite{Huang:INDOCRYPT'08}&nG$_{1}$&nG$_{1}$+G$_{2}$&t$_{p}$+nt$_{e1}$+t$_{e2}$&2t$_{p}$+(2k+1)t$_{2e}$&Decisional BDH ssumption\\
\hline
\cite{Zhen:ESORICS'11}&nG$_{1}$&(2n+1)G$_{1}$+G$_{2}$&t$_{p}$+3nt$_{e1}$+t$_{e2}$&(n+1)t$_{e2}$+(2n+1)t$_{p}$&Number-Theoretic  assumptions\\
\hline
\cite{Yannis:FC'15}&4G$_{1}$&(2n+1)G$_{2}$+4nG$_{1}$&t$_{p}$+4kt$_{e1}$+(2k+1)t$_{e2}$&2t$_{p}$+3t$_{e2}$&Complexity assumption\\
\hline
\cite{XiaoFang:ICCCN'15}&(3n+k)G$_{1}$&(2n+1)G$_{1}$+G$_{2}$&t$_{p}$+(2n+1)t$_{e1}$+t$_{e2}$&(2k+5)t$_{p}$+(2k+5)t$_{e2}$&      Decisional BDH assumption\\
\hline
\cite{Qi:Wiley'15}&2G$_{1}$&(5n+1)G$_{1}$+G$_{2}$&t$_{p}$+(3w+1)t$_{e1}$+t$_{e2}$&(3n+1)t$_{e2}$+(3n+1)t$_{p}$&z-type assumption\\
\hline
\end{tabular}
\end{table*}
\\
%\begin{table}
%\caption{performance comparison}
% \centering
%\begin{tabular}{|c|c|c|}
%\hline
%scheme&encryption&decryption\\
%\hline
%\cite{Chase:TCC'07}&t$_{p}$+nt$_{e1}$+t$_{e2}$&t$_{p}$+kt$_{e2}$\\
%\hline
%\cite{Huang:INDOCRYPT'08}&t$_{p}$+nt$_{e1}$+t$_{e2}$&2t$_{p}$+(2k+1)t$_{2e}$\\
%\hline
%\cite{Zhen:ESORICS'11}&t$_{p}$+3nt$_{e1}$+t$_{e2}$&(n+1)t$_{e2}$+(2n+1)t$_{p}$\\
%\hline
%\cite{Yannis:FC'15}&t$_{p}$+4kt$_{e1}$+(2k+1)t$_{e2}$&2t$_{p}$+3t$_{e2}$\\
%\hline
%\cite{XiaoFang:ICCCN'15}&t$_{p}$+(2n+1)t$_{e1}$+t$_{e2}$&(2k+5)t$_{p}$+(2k+5)t$_{e2}$\\
%\hline
%\cite{Qi:Wiley'15}&t$_{p}$+(3w+1)t$_{e1}$+t$_{e2}$&(3n+1)t$_{e2}$+(3n+1)t$_{p}$\\
%\hline
%\end{tabular}
%\end{table}

\subsection{Revocation (by Xiping Zhang)}
\indent Revocation mechanism is necessary for any encryption schemes that involve many users,since a user$^{'}$s permissions change and key leakage may happen with time. Attrapadung,Imai \emph{et al.} \cite{Nuttapong:ICCC'09} first divided revocation mechanism into two types: direct revocation and indirect revocation according to the different executor. In an indirect revocation scheme, the key authority, who possesses the current revocation list, periodically announces a key update material at each time slot so that only non-revoked users can update their key and use it to decrypt ciphertexts encrypted at the present time. In a direct revocation scheme, senders are able to specify the revocation list directly when encrypting.But both schemes have some problem: The indirect revocation scheme the key update phase can be a bottleneck since it requires communication from the key authority to all non-revoked users at all time slots.The direct revocation scheme requires senders to possesses the current revocation list. It could be a troublesome task to manage the revocation list. Attrapadung,Imai \emph{et al.} \cite{Nuttapong:ICCC'09} designed a hybrid revocable ABE scheme that allows the senders to select when encrypting whether to use either direct or indirect revocation mode, and the reciever possesses only one key but will be able to decrypt ciphertexts that were constructed in either modes.\\
\indent The directly revocation CP-ABE scheme is as follows:\\
\noindent \textbf{Setup} The algorithm first picks a random generator g, v, h$_0$,\ldots, h$_{m'}$$\in$G and random $\alpha$, a, b$\in$Z$_p$. The public key is pk=(g, g$^a$, g$^{b^2}$, v, v$^b$, g$^a$, h$_0$,..., h$_m'$,e(g,g)$_α$). The master key is msk=($\alpha$,b). It outputs(pk,msk). Define a function F:Zp$\rightarrow$G by F(x)=$\prod_{j=0}^{m'}$h$_j^{(x^j)}$\\
\noindent \textbf{Encrypt}(S,(M,ρ),M,pk) Inputs to the encryption algorithm are a user index set S$\supset$U and a LSSS access structure (M, ρ) for subjective policy. Let M be l$_s$ $\times$ k$_s$ matrix.Let R=U$\backslash$S. Denote R= /{ID$_1$,...ID$_r$/}. The algorithm first randomly chooses s,y$_2$,...,y$_{k_s}$$\in$Z$_p$ and lets u=(s,y$_2$,...,y$_{k_s}$). For i= 1 to l$_s$,it calculates λ$_i$=M$_i$$\cdot$u,where M$_i$ is the vector corresponding to ith row of M.It also chooses random s$_1$,...s$_r$$\in$Z$_p$,such that s= s$_1$+ ...+ s$_r$.The ciphertext ct is set to ct=(C,C$_1$,\{C$_i^{(2)}$\}$_{i\in[1,l_s]}$, \{C$_i^{(3)}$\}$_{j\in[1,r]}$,\{C$_i^{(4)}$\}$_{j\in[1,r]}$),where    \\ \\
\indent C=M$\cdot(e(g,g)^α)^s$, \hspace{1cm} C$_1$=g$^s$,\hspace{2cm}  C$_i^{(2)}$=g$^aλ_i$F(ρ(i))$^{-s}$,\\
\indent C$_j^{(3)}$=g$^{b\cdot s_j}$,\hspace{1.87cm} C$_j^{(4)}$=(g$^{b^2\cdot ID_j}$v$^b$)$^{s_j}$.\\\\
\noindent \textbf{KeyGen}(ID, $\rho$, msk, pk) Inputs to the encryption algorithm are a user index ID$\in$U and an attribute set$\psi\supset$N.The algorithm randomly chooses t,r$\in Z_p$.It outputs the private key as sk=(D$^{(1)}$,D$^{(2)}$,\{D$_x^{(3)}$\}$_{x\in\psi}$,D$^{(4)}$,D$^{(5)}$)where\\
\indent D$^{(1)}$=g$^{\alpha+b^2t}\cdot$g$^{ar}$, \hspace{1cm} D$^{(2)}$=g$^r$,  \hspace{1cm}    D$_x^{(3)}$=F(x)$^r$,\\
\indent D$^{(4)}$=(g$^{b\cdot ID}$v)$^t$, \hspace{1.17cm} D$^{(5)}$=g$^t$.\\\\
\noindent\textbf{Decrypt}(ct,(S,(M,$\rho$)),sk,(ID,$\psi$),pk) Suppose that the attribute set $\psi$ satisfies the access structure (M, $\rho$)) and the user index ID$\in$ S (so that the decryption is possible). Let I$_s$=\{i$\rho(i)\in\psi$\}.It then calculates corresponding sets of reconstruction constants\{(i,$\mu_i$)\}$_{i\in I_s}$=Recon$_{(M,\rho)}(\psi)$.Then it computes\\
K=$\dfrac{e(C^{(1)},D^{(1)})}{\prod_{i=1}^{l_s}\left(e(C_i^{(2)},D^{(2)})\cdot e(C^{(1)},D^{(3)}_{\rho(i)})\right)^{\mu_i}}\cdot\prod_{j=1}^{r}\left(\dfrac{e(D^{(5)},C^{(4)}_j)}{e(D^{(4)},C^{(3)}_j)}\right)^{1/(ID-ID_j)} $ \\
where it can compute since ID=ID$_j$ for j=1,...,r. It then obtains M=C/K.\\\\
\\ \\
\indent In order to reduce the costs during the update phase,Liang, Xiaohui,Lu, Rongxing\cite{Xiaohui:Citeseer'10} designed a efficient scheme which used the binary tree technique to build a revocation tree. The revocation tree corresponds to time t and the identifier of revoked user is uid which is associated with one leaf node. In comparison with the traditional ciphertext policy attribute based encryption,the size of user secret key is increased by multiplying logn. In this scheme,the system manager should only publishes the revocation information according to a time stamp.The primary trigger control of the user’s access ability is the update information.In direct revocation, Pratish Datta, Ratna Dutta\cite{Pratish:ISC'15}combined some existing encrypt technology and revocation technology, achieve very short ciphertext size without imposing any extra overhead on the decryption key for the added revocation functionality and reduce the number of group elements in the public parameters to logN$_{max}$\\
\indent The revocation can also execute on uesrs$^{'}$ one attribute. Li, Qiang,Feng,Dengguo\cite{Qiang:GLOBECOM'12}implant attributes into users’private key.It can revoke a user$^{'}$s one attribute without influencing his private key,if the revoked user’s other attributes also satisfy the access structure,he can decrpyt the cipertext successfully.This realize fine-gained attribute revocation under direct revocation model.\\
\indent There are also a “direct revocation” scheme called third-part revocation.The bring in of third-part to execute revocation can reduce the authority’s work. Shi, Yanfeng,Zheng, Qingji \emph{et al.} researched this scheme and get ahead. In\cite{Yanfeng:InSc'15}, the ciphertext is divided into two part: the data and the authorize(identity)part,the trusted authority is allowed to revoke users by updating the revocation list and the third part is allowed to update ciphertexts with public information.\\
\indent In addition,it’s important to avoid the abuse of key, that is to trace the malicious user, Liu, Zhen,Wong, DuncanS\cite{Zhen:CJ'15} make great progress on blackbox trace, which is highly expressive and achieves the most efficient level to date.\\ \\
Some comparison of the efficiency of the schemes are as follows.\\
%\begin{table*}[t]
%\centering  % 表居中
%\caption{comparison among revocation}
%\label{tab:comvoca}
%\begin{tabular}{|c|c|c|c|c|c|c|c}
%\hline
%scheme&CP-ABE&KP-ABE&Directly&Indirectly&Ciphertext Size&SK Size&Decryption cost\\
%\hline
%\cite{Shlomi:CyberSecurity'12}&$\surd$&$\times$&$\surd$&$\times$&(2r+1)$|G_1|$&$3|G_1|+|G_2|$&3P\\
%\hline
%\cite{NuttapongAttrapadung:{2009}}(scheme1)&$\times$&$\surd$&$\surd$&$\times$&$(\omega+2)|G_1|+|G_2|$&$2l_0|G_1|$&$(2l_0+2)P+l_0E_{G2}$\\
%\hline
%\cite{NuttapongAttrapadung:{2009}}(scheme2)&$\times$&$\surd$&$\surd$&$\times$&$(2r+\omega+1)|G1|+|G2|$&$(2l_0+2)|G1|$&$(2l_0+2r)P+(l_0+r)E_{G2}$\\
%\hline
%\cite{NuttapongAttrapadung:{2009}}(scheme1)&$\surd$&$\times$&$\surd$&$\times$&$(l_s+2)|G1|+|G2|$&$(2l_s+3)P+l_sE_{G2}$&$3|G1|$\\
%\hline
%\cite{NuttapongAttrapadung:{2009}}(scheme2)&$\surd$&$\times$&$\surd$&$\times$&$4|G1|+|G2|$&$5|G1|$&$(2l_s+2r+1)P+(l_s+r)E_{G2}$\\
%\hline
%\cite{Xiaohui:Citeseer'10}&$\times$&$\surd$&$\surd$&$\times$&$(3+l_{n_{max}})|G1|+|G2|$&$(n_{max}+|S|+3)|G1|$&$(n_{max}+6)P+(n_{max}|I|+|I|+2)E_{G2}$\\
%\hline
%\cite{Qiang:GLOBECOM'12}&$\surd$&$\times$&$\surd$&$\times$&$(2\omega-j+2)|G1|+|G2|$&$(4l+n)|G1|$&$2(\omega-j)P+(\omega-j)E_{G2}$\\
%\hline
%\end{tabular}
%\end{table*}
\begin{table*}[t]
\centering  % 表居中
\caption{comparison among revocation}
\label{tab:comvoca}
\begin{tabular}{|c|c|c|c|c|c|c|}
\hline
Scheme&Types&Directly&Indirectly&Ciphertext Size&SK Size&Decryption cost\\
\hline
\cite{Shlomi:CyberSecurity'12}&CP&$\surd$&$\times$&(2r+1)$|G_1|$&$3|G_1|+|G_2|$&3P\\
\hline
\cite{NuttapongAttrapadung:{2009}}(scheme1)&KP&$\surd$&$\times$&$(\omega+2)|G_1|+|G_2|$&$2l_0|G_1|$&$(2l_0+2)P+l_0E_{G2}$\\
\hline
\cite{NuttapongAttrapadung:{2009}}(scheme2)&KP&$\surd$&$\times$&$(2r+\omega+1)|G1|+|G2|$&$(2l_0+2)|G1|$&$(2l_0+2r)P+(l_0+r)E_{G2}$\\
\hline
\cite{NuttapongAttrapadung:{2009}}(scheme1)&CP&$\surd$&$\times$&$(l_s+2)|G1|+|G2|$&$(2l_s+3)P+l_sE_{G2}$&$3|G1|$\\
\hline
\cite{NuttapongAttrapadung:{2009}}(scheme2)&CP&$\surd$&$\times$&$4|G1|+|G2|$&$5|G1|$&$(2l_s+2r+1)P+(l_s+r)E_{G2}$\\
\hline
\cite{Xiaohui:Citeseer'10}&KP&$\surd$&$\times$&$(3+l_{n_{max}})|G1|+|G2|$&$(n_{max}+|S|+3)|G1|$&$(n_{max}+6)P+(n_{max}|I|+|I|+2)E_{G2}$\\
\hline
\cite{Qiang:GLOBECOM'12}&CP&$\surd$&$\times$&$(2\omega-j+2)|G1|+|G2|$&$(4l+n)|G1|$&$2(\omega-j)P+(\omega-j)E_{G2}$\\
\hline
\end{tabular}
\end{table*}




%\subsection{hide-policy ABE}
%hide-policy ABE goes here.
